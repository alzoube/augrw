<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8">
  <title></title>
  <style>
    canvas {
        border: 1px solid rgba(0, 0, 0, 0);
        font-family: "Helvetica Neue", "Arial", "Lucida Grande", "Lucida Sans Unicode", "Microsoft YaHei", sans-serif;
        font-size: 5px;
        line-height: 1.5;
        color: #474747;
        background: transparent; 
    }

    #toolbar {
        width: 100%;
        border: 1px solid black;
        border-bottom: 0px;
        padding: 5px;
        background-color: #f8f8f8;
    }

    input[type = 'text'] {
        width: 30px;
        margin: 0px 5px 0px 5px;
    }

    label {
        margin-left: 40px;
    }

    label:first-of-type {
        margin-left: 0px;
    }

    input[type = 'button'] {
        float: right;
    }

    #colorSquare {
        position: relative;
        display: inline-block;
        width: 20px;
        height: 20px;
        background-color: #0c7fb9;
        top: 4px;
    }

    button {
            /* Style the button here */
            background-color: #a8d8ec; /* Light gray background */
            color: #333; /* Dark gray text */
            padding: 10px 10px; /* Add some padding */
            border: none; /* Remove default border */
            border-radius: 4px; /* Add rounded corners */
            cursor: pointer; /* Indicate clickable behavior */
            font-size: 22px;
            }

            button:hover {
            /* Change styles on hover */
            background-color: #5ed0e4; /* Slightly darker on hover */
            }

            span, label{
                color: #2876a7;
                font-size: 30px;
                font-weight: bold;
            }
          select{
                color: #078391;
                font-size: 20px;
             
            }


    
    
  </style>

    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "../jsm/"
            }
        }
      </script>


  <script src="../dist/tesseract.min.js"></script>
  <script type="text/javascript" src="../js/cv.js"></script>
  <script type="text/javascript" src="../js/aruco.js"></script>
   <script src="events.js"></script> 


  
</head>
<body>
    <div id="root">

        <video id="webcam" width="640" height="480" style="display:none;"></video>

        <div id="sep"></div>
        <div id="messages"></div>
        <canvas id="canvas" width="480" height="480" style="border: 3px solid skyblue;display:none;"></canvas>
        <canvas id="canvasC" width="640" height="480" style="border: 3px solid #32cd32;display:none;"></canvas>

    </div>


    <div id="toolbar" >
        <label for="dropdown">
            Lesson:
        </label>
        <select id="dropdown">
            
        </select> 

        <label for="clr">
            Color
        </label>
            <input type="color" id="clr"   value="#f6b73c">
        <label>
            Size:
        </label>
        <input type="range" id="textsize" min="5" max="20" value="10" step="5">
        <button type="button" id="clearButton" value="Clear">Clear </button>
        <button type="button" id="play_button"   value="Stop Video">Stop Video </button>
        <button type="button" id="scan_button"  value="Start AR">Start AR </button>

    </div>
    <canvas id="myCanvas" width="1000" height="650" style="position:absolute;">
    </canvas>



</body>
                           

<script>


 function addPoint(events, points){
               var context = events.getContext();

                var drawingPos = events.getMousePos();
                var touchPos = events.getTouchPos();


                if (drawingPos !== null) {
                    points.push(drawingPos);
                }
                if (touchPos !== null) {
                    points.push(touchPos);
                }
            }


function drawWord(word){

                canvasImg = getCanvasImg(canvas);
                console.log("draw word");

                var context = canvas.getContext("2d");

                // clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);

                // redraw canvas before path
                context.drawImage(canvasImg, 0, 0, canvas.width, canvas.height);

                //Draw word
                context.beginPath();
                context.font = "200pt Calibri";
                //context.font = "200pt 'Comic Sans MS' ";
                context.fillStyle = "white";
                context.strokeStyle = "#0c7fb9";
                context.textAlign = "right";
                context.lineWidth = 3;
                // align text vertically center
                context.textBaseline = "middle";
                //context.fillText(word, canvas.width / 2, 100);
                context.strokeText(word, canvas.width / 1.2, 240);
            }



            function drawPath( points, canvasImg){
           //  var   context = canvas.getContext("2d");

                context.drawImage(canvasImg, 0, 0, canvas.width, canvas.height);

                // draw patch
                context.beginPath();
                context.lineTo(points[0].x, points[0].y);
                for (var n = 1; n < points.length; n++) {
                    var point = points[n];
                    context.lineTo(point.x, point.y);
                }
                context.stroke();
            } 

 function getCanvasImg(canvas){

                //console.log("get image");
                var img = new Image();
                img.src = canvas.toDataURL();
                return img;
            }
   

///////////////////////////////////////////////////////////////////


        window.onload = function(){

//console.log("onLoad");
            var events = new Events("myCanvas");
            canvas = events.getCanvas();
            context = events.getContext();
            var isMouseDown = false;
            var canvasImg = getCanvasImg(canvas);
            var points = [];


            // document.getElementById("clearButton").addEventListener("click", function(evt){
            //     events.clear();
            //     points = [];
            //     canvasImg = getCanvasImg(canvas);

            // }, false);




            document.getElementById("clearButton").addEventListener("click",clearCanv , false);
            function clearCanv(evt){
                events.clear();
                points = [];
                canvasImg = getCanvasImg(canvas);
            }
            window.clearCanv = clearCanv;

            canvas.addEventListener("mousedown", function(){

                //console.log("down");

                var drawingPos = events.getMousePos();

                // update drawing params

                size = document.getElementById("textsize").value;

                // start drawing path

                context.strokeStyle = document.getElementById("clr").value;

                context.lineWidth = size;
                context.lineJoin = "round";
                context.lineCap = "round";
                addPoint(events, points);
                isMouseDown = true;
            }, false);

            canvas.addEventListener("mouseup", function(){

                //console.log("up");

                isMouseDown = false;
                if (points.length > 0) {
                    drawPath( points, canvasImg);
                    // reset points
                    points = [];
                }
                canvasImg = getCanvasImg(this);
            }, false);

            canvas.addEventListener("mouseout", function(){

                //console.log("out");

                if (document.createEvent) {
                    var evt = document.createEvent('MouseEvents');
                    evt.initEvent("mouseup", true, false);
                    this.dispatchEvent(evt);
                }
                else {
                    this.fireEvent("onmouseup");
                }
            }, false);

            //drawWord(canvas, "PSUT", canvasImg);

            events.setStage(function(){
                //console.log("set stage");
                if (isMouseDown) {

                    addPoint(this, points);
                    drawPath( points, canvasImg);
                }
            });


 ///////////////////////////////////////////////////////


                canvas.addEventListener("touchstart", function(){

                    //console.log("touchstart");
                   // var touchPos = events.getTouchPos();
                     // update drawing params

                size = document.getElementById("textsize").value;

                // start drawing path

                context.strokeStyle = document.getElementById("clr").value;

                context.lineWidth = size;
                context.lineJoin = "round";
                context.lineCap = "round";
                addPoint(events, points);
          

                    points = [];
                   // addPoint(events, points);
                    isMouseDown = true;
                }, false);
                
                canvas.addEventListener("touchend", function(){

                   // console.log("touchend");
                    isMouseDown = false;

                 
                    if (points.length > 0) {
                        drawPath( points, canvasImg);
                        // reset points
                        points = [];
                    }
                    canvasImg = getCanvasImg(this);
                }, false);
    


        };//onLoad


       
</script>
 
 
 
 
 
 
 
 
 
 
 
                                    <!-- Init -->

    <script type="module">

            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/OrbitControls.js';
            import Stats from 'three/addons/libs/stats.module.js';
            import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

            const clock = new THREE.Clock();

    let animations,camera,scene,mixer,actions = [], objects, models3d =[], Lmixer, Lanims =[], action;
    var canvas, context; 
    var texture;
    var  renderer, orthoScene, orthoCam, controls;

    var width = window.innerWidth;
    var height = window.innerHeight ;
    var markers, detector;

    var warpImage, homographyImageR, homographyImageG, homographyImageB;
    //var aImageData =[];
    var cnvs;
    var cxt;
    var offset =10;
    let rotation = 0;
    var img;

    let vocab = ["one", "swim", "run","laugh", "clap", "think", "salute", "angry", "talk", "victory", "pray", "look", "fly", "crawl", "climb", "throw"];
    var doc= document.querySelector('#root');
    var synth = window.speechSynthesis;

    var voices = [];
    var dictionary = {};
    var selectedValues = [];
    window.lesson =[];
    var successSound;
    var isCorrect =false;


    var word, model;
    var moveIt=false;

    var loader;

////////////////////////////////////////////////////////////////////////////////

    function populateVoiceList() {
        voices = synth.getVoices();
    }

    populateVoiceList();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoiceList;
    }
    const messages = document.getElementById('messages');
    let timerId = null;
    var c;




    // Create a webcam capture
    var video = document.getElementById('webcam');
    console.log("Start Video");
      
    navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'environment'
            }
        })
        .then(function(stream) {
           
            video.srcObject = stream;
            video.play();
        })
        .catch(function(err) {
            console.log('An error occurred: ' + err);
    });


    const addMessage = (m, bold) => {
        let msg = `<p>${m}</p>`;
        if (bold) {
        msg = `<p class="bold">${m}</p>`;
        }
        messages.innerHTML = msg;
        messages.scrollTop = messages.scrollHeight;
    }
    cnvs = document.getElementById('canvas');
    cxt = cnvs.getContext('2d');

    warpImage = cxt.createImageData(160, 160);
    homographyImageR = new CV.Image();
    homographyImageB = new CV.Image();
    homographyImageG = new CV.Image();





//****************************     Start  Video ************************************//


        var button = document.getElementById('play_button');
        button.onclick = function() {
            if (button.value === 'Play Video') {
                
                navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment'
                    }
                })
                .then(function(stream) {
                    
                    video.srcObject = stream;
                    video.play();
                    })
                    .catch(function(err) {
                        console.log('An error occurred: ' + err);
                });

            
                
                button.value = 'Stop Video';
                button.innerText = 'Stop Video';


                //scene.background = new THREE.Color( 0x000000);
            } else {
               // scene.background = new THREE.Color( 0xffffff );
                var tracks = video.srcObject.getTracks();

                // Stop each track
                tracks.forEach(function(track) {
                    track.stop();
                });
               // clearInterval(timerId);//stop AR
                button.value = 'Play Video';
                button.innerText = 'Play Video';
            }
        }

//***********************      Start AR     *****************************//


        var sbutton = document.getElementById('scan_button');
        sbutton.onclick = function() {
            
            if (sbutton.value === 'Start AR') {


              //  console.log(sbutton.value);
                sbutton.value = 'Stop AR'; 
                sbutton.innerText= 'Stop AR';               
                timerId = setInterval(doOCR, 2000);

            }else{
                sbutton.value ='Start AR';
                sbutton.innerText ='Start AR';
                clearInterval(timerId);
            }
        }




                        //                <!-- OCR -->


    var worker;

    (async () => {
        worker = await Tesseract.createWorker("eng", 1, {
            workerPath: "../dist/worker.min.js"
         });

        c = document.createElement('canvas');
        c.width = 640;
        c.height = 480;

        initARApp();
        //initAudio();


                // read lessons
                fetch('Lessons.json')
                        .then(response => response.json())
                        .then(data => LoadLessons(data))
                        .catch(error => console.log('Error:', error));

                    
                    dropdown.addEventListener('change', function() {
                      
                        var selectedValue = this.value;           
                        selectedValues  = dictionary[selectedValue];
                        

                        window.lesson = selectedValues;
                        console.log(lesson);


                        animIdx=0;
                        odx=0;
                        actions=[];
                        models3d =[];
                        Lanims =[];

                        loadNextAnim(loader);
                    });

        detector = new AR.Detector();
    })();


    function LoadLessons(data){

            console.log("Lessons loaded")
            // console.log(data)

            var str = JSON.stringify(data);
            dictionary = JSON.parse(str);

            // Get the dropdown element
            var dropdown = document.getElementById('dropdown');

            // Get the keys of the dictionary
            var keys = Object.keys(dictionary);

            //console.log(keys)

            // Loop through the keys and create an option for each one
            for (var i = 0; i < keys.length; i++) {
                var option = document.createElement('option');
                option.text = keys[i];
                option.value = keys[i];
                dropdown.add(option);
            }           
    }


    const doOCR = async () => {
        console.log("deOC");
        const cctx = c.getContext('2d', {willReadFrequently: true});
        cctx.drawImage(video, 0, 0, 640, 480);

        let pixels =cctx.getImageData(0,0,640,480);

        markers = detector.detect(pixels);

        if(markers.length > 0){
            //console.log(markers.length);
            drawWarpsC(detector.red,detector.green, detector.blue, detector.candidates);
        }
    }

    async  function drawWarpsC(red, green, blue, contours){
        console.log("drawWarpC");
        let contour;
        cxt.clearRect(0, 0, cnvs.width, cnvs.height);

        for(let i=0; i<contours.length; i++){
            contour = contours[i];

            CV.warp(red, homographyImageR, contour, warpImage.width);
            CV.warp(green, homographyImageG, contour, warpImage.width);
            CV.warp(blue, homographyImageB, contour, warpImage.width);

            createImageC(homographyImageR,homographyImageG,homographyImageB, warpImage);
            cxt.putImageData(warpImage, 0, 0);
            //img.src = canvas.toDataURL();
            TryOCR2Text(warpImage);

            // context.putImageData(warpImage, 0, 0, offset, offset, cnvs.width-(offset*2),cnvs.height-(offset*2));
            // let id = context.getImageData(0, 0, cnvs.width-(offset*2),cnvs.height-(offset*2));
            // img.src = cnvs.toDataURL();
            // TryOCR2Speek(id);
            // for(i=1;i<=3;i++){
            //     rotation += 90;
            //     if (rotation === 270) {
            //         rotation = 0;
            //     }
            //     img.style.transform = `rotate(${rotation}deg)`;
            //     cxt.drawImage(img, 0, 0);
            //     let id = context.getImageData(0, 0, cnvs.width,cnvs.height);
            //     TryOCR2Speek(id);
            // }

        }
    }

    async function TryOCR2Text(pxls){

        console.log("TryOCR2Text");
        var image = document.createElement("img");
        var croppedImage = document.createElement("img");
        let d=pxls.data;
        let threshold =150;
        //W/B
        for (let i=0; i<d.length; i+=4) {
            let r = d[i];
            let g = d[i+1];
            let b = d[i+2];
            let v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;
            d[i] = d[i+1] = d[i+2] = v
        }
        //console.log(canvas);
        cxt.putImageData(pxls,0,0);
        image.src = cnvs.toDataURL();

    //Crop

        var sourceCanvas = document.getElementById('canvas');
        var sourceContext = sourceCanvas.getContext('2d', {willReadFrequently: true});

        var destinationCanvas = document.getElementById('canvasC');
        var destinationContext = destinationCanvas.getContext('2d', {willReadFrequently: true});

        var cropX = 10, cropY = 10, cropWidth = 140, cropHeight = 140;

        destinationContext.drawImage(sourceCanvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        const croppedImageData = destinationContext.getImageData(0, 0, cropWidth, cropHeight);
        croppedImage.src = destinationCanvas.toDataURL();

        const { data: { text } } = await worker.recognize(destinationCanvas);

        console.log(text);

        addMessage(text);

        let text2 = text.substring(0,text.length-1);
        //console.log(text2);
        text2=text2.toLowerCase();


        if(lesson.includes(text2)){

            drawWord( text2);
            SpeakandAnimate(text2);

        }
    }


                     //                   <!-- Speech -->



    function SpeakandAnimate(message){

         if (message !== '') {


//**********************       Succes / Fail    (Rcognision of the word marker)  **********************//

        models3d.forEach(function(mdl) {
                    mdl.visible=false;

        });



            let idx =lesson.indexOf(message);
            //console.log("idx: "+ idx);

            successSound.play();
            if(idx != -1) {

                if(Lanims.indexOf(message) != -1 ){

                    playAnimationByName(message, 2) ;                
                }              
                else{  //// an Object ?


                    models3d.forEach(function(mdl) {
                        mdl.visible=false;
                        if(mdl.name === message){
                            model=mdl;
                        }
                    });

                        models3d[idx].visible=true; 
                }

                clearInterval(timerId);
                sbutton.value ='Start AR';
                sbutton.innerText ='Start AR';       
                SayIt(message);
                setTimeout(SayIt(message ), 1000);
                setTimeout(SayIt("Congratulations!  Now learn how to write the word "+message ), 2000);

            }
        }
    }


    function SayIt(message){
        if (synth.speaking) {
            console.error('speechSynthesis.speaking');
           // return;
        }

        if (message !== '') {
            var utterThis = new SpeechSynthesisUtterance(message);
            utterThis.onend = function (event) {
                console.log('SpeechSynthesisUtterance.onend');
            }
            utterThis.onerror = function (event) {
                console.error('SpeechSynthesisUtterance.onerror');
            }

            console.log("Voices No = "+voices.length);
            utterThis.voice = voices[1];///////????
            utterThis.pitch = '0.5';
            utterThis.rate = '1.0';
            synth.speak(utterThis);
            
        //console.log("Uttered!");

        }
    }

    function createImageC(Rd, G, B, dst){
        let i = Rd.data.length, j = (i * 4) + 3;

        while(i --){
            dst.data[j -= 4] = 255;
            dst.data[j - 1] = B.data[i];
            dst.data[j - 2] = G.data[i];
            dst.data[j - 3] = Rd.data[i];
        }

        return dst;
    }
    function createImage(src, dst){
        let i = src.data.length, j = (i * 4) + 3;

        while(i --){
            dst.data[j -= 4] = 255;
            dst.data[j - 1] = dst.data[j - 2] = dst.data[j - 3] = src.data[i];
        }

        return dst;
    }
    function VerifyText(text){
        return vocab.includes(text);
    }


                       //                 <!-- Animation -->




    function initARApp() {

        console.log("Init App");
        texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        texture.generateMipmaps = false;
        texture.type = THREE.UnsignedByteType;
        texture.format =THREE.RGBAFormat;

        animations = ["idle", "talk", "wave", "victory"];
        //lesson = ["table lamp","watering can","lighter","racket","lantern","fan","bottle","bucket","pan", "clock", "chair", "hat", "orange", "table", "clap", "swim", "climb", "fly", "throw", "crawl", "jump", "run"];

        lesson = ["table", "chair", "tent", "fan"];

        console.log(lesson);


        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.set( 0, 100, 400 );

        scene = new THREE.Scene();

        //Light
       //scene.background = new THREE.Color( 0xffffff );
        let hlight = new THREE.HemisphereLight( 0xffffff, 0x444444,1 );
        hlight.position.set( 0, 200, 0 );
        scene.add( hlight );

        let dlight = new THREE.DirectionalLight( 0xffffff, 5 );
        dlight.position.set( 0, 200, 100 );

        scene.add( dlight );
        const targetObject = new THREE.Object3D();
        targetObject.position.set(150,50,80);
        scene.add(targetObject);
        dlight.target = targetObject;

        const alight = new THREE.AmbientLight( 0x909090 ); // soft white light
        scene.add( alight );


        // ground
        const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
        mesh.rotation.x = - Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add( mesh );
        mesh.position.set(120,50,50);


        const grid = new THREE.GridHelper( 100, 20, 0x000000, 0x000000 );
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add( grid );
        grid.position.set(120,50,50);

        orthoCam = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
        // orthoCam.position.set(0, 0, 0);
        orthoScene = new THREE.Scene();
        orthoScene.background = new THREE.Color( 0xffffff );

        var videoMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            });
        var videoGeometry = new THREE.PlaneGeometry(1, 1);
        var videoMesh = new THREE.Mesh(videoGeometry, videoMaterial);
        videoMesh.position.set(0, 0, 0);
        orthoScene.add(videoMesh);

        // models

        loader = new FBXLoader();

        //loadLesson(loader);

        loader.load( '../idle.fbx', function ( object ) {

            if(mixer === undefined)  mixer = new THREE.AnimationMixer( object );
            scene.add( object );
            object.position.set(120,50,50);
            object.rotation.y=-0.4;

            loadNextAnim(loader);
            
        } );


        renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth-100, window.innerHeight-100 ); 
        renderer.autoClear = false;

        container.appendChild( renderer.domElement );
     
        controls = new OrbitControls( camera, renderer.domElement );
        controls.target.set( 0, 150, 0 );
        controls.update();
        window.addEventListener( 'resize', function(){ resize();}, false );




        // Create an audio listener and add it to the camera
        const listener = new THREE.AudioListener();
        camera.add(listener);

        // Create an audio source and load a sound
        successSound = new THREE.Audio(listener);
        const aloader = new THREE.AudioLoader();
        aloader.load('sounds/success.mp3', function(buffer) {
        // Set the buffer and loop properties of the sound
        successSound.setBuffer(buffer);
        successSound.setLoop(false);
        successSound.setVolume(1);
        });

    }//init()


    let odx=0;
    function loadLesson(loader){

        console.log("Load lesson");
            const obj= lesson[odx];


            odx++;
            loader.load(`../${obj}.fbx`, function ( object ) {

            if(mixer === undefined) mixer = new THREE.AnimationMixer( object );
        // Check if the object has any animations
        if (object.animations.length > 0) {
            //console.log('The object has ' + object.animations.length + ' animations');
            action = mixer.clipAction(object.animations[0]);
            action._clip.name = obj;
            actions.push(action);
            Lanims.push(obj);
            console.log(obj);

        } else {

                scene.add( object );

                // object.traverse(function (child) {
                //     if ((child as THREE.Mesh).isMesh) {
                //         // (child as THREE.Mesh).material = material
                //         if ((child as THREE.Mesh).material) {
                //             ((child as THREE.Mesh).material as THREE.MeshBasicMaterial).transparent = false
                //         }
                //     }
                // })

                
                object.position.set(-20,80,180);
                object.name=obj;
                models3d.push(object);
                object.visible = false;
                console.log(object);
                //object.rotation.y=-0.6;
            //console.log('The object has no animations');
        }

        } );

        if(odx<lesson.length)  {
            loadLesson(loader);
        }   
        else{
            
            
            //********************    Start here    ************************//




            console.log(actions);
            console.log(models3d);
            animate();     
            playWaveAnimation();
    
          //  SayIt("welcomt to augmented reality learning platform. Let's Begin! Scan A word and press the Start button.");
        
            mixer.addEventListener('finished', NextAnim) ;
        }
    }



    let animIdx=0;
    function  loadNextAnim(loader){
        const anim = animations[animIdx];
        animIdx++;
        loader.load( `../${anim}.fbx`, function ( object ) {

            action = mixer.clipAction(object.animations[0]);
            action._clip.name = animations[animIdx-1];
            actions.push(action);
            console.log('clips No: ' +actions.length);
            console.log(action);

            if(animIdx<animations.length) {
                loadNextAnim(loader);
            }
            else{
                loadLesson(loader);
            }


        });
    }



    function NextAnim(e){       
         playIdleAnimation();
           
    }



    var clipName;
    function  playAnimationByName(clip, n){
        mixer.stopAllAction();

        let idx =lesson.indexOf(clip);

        let NoM = models3d.length;
        const action = actions[idx+4-NoM];
        clipName=action._clip.name;
        console.log("clip name:  "+clipName); 
        action.setLoop(THREE.LoopRepeat , n);
        action.weight = 1;
        action.fadeIn(0.8);       
        action.play();     
    }
    function  playAnimation(index){
        mixer.stopAllAction();
        const action = actions[index];
        const clipName=action._clip.name;
        console.log("clip name:  "+clipName);
        action.setLoop(THREE.LoopRepeat , 3);
        action.weight = 1;
        action.fadeIn(.8);
        action.play();
    }

    function  playIdleAnimation(){
        mixer.stopAllAction();
        const action = actions[0];
        //console.log(action);
        action.weight = 1;
        action.fadeIn(0);
        //action.clampWhenFinished = true;
        action.play();
    }

    function  playWaveAnimation(){
        mixer.stopAllAction();
        const action = actions[2];
        action.weight = 1;
        action.fadeIn(.8);
        action.setLoop(THREE.LoopRepeat , 5);
        //action.clampWhenFinished = true;
        action.play();
    }

    function  playTalkAnimation(){
        mixer.stopAllAction();
        const action = actions[1];
        action.setLoop(THREE.LoopRepeat , 1);
        action.weight = 1;
        action.fadeIn(.8);
        action.play();
        //action.clampWhenFinished = true;
    }
    function  playVictoryAnimation(){
        mixer.stopAllAction();
        const action = actions[3];
        action.setLoop(THREE.LoopRepeat , 1);
        action.weight = 1;
        action.fadeIn(.8);
        action.play();
    }

    function  resize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth-100, window.innerHeight-100 );
    }


    function animate() {

        requestAnimationFrame( function(){animate(); } );

        if (video.readyState === video.HAVE_ENOUGH_DATA) {

            texture.needsUpdate =true;
            renderer.clear();
            renderer.render(orthoScene, orthoCam);
            
            renderer.clearDepth();
        
           renderer.render(scene, camera);
        }
        const delta = clock.getDelta();

        if ( mixer ) mixer.update( delta );


        if(model){

            model.rotation.y +=0.01;

            if(moveIt){
                if(model.position.x < 100){
                    model.position.x+=1;
                }else{

                    model.scale.set(0.9, 0.9, 0.9);
                }
            }
        }
    }


//*******************    Audio   *********************//


    const audioClips = [];

</script> 

</html>